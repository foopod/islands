<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Procedural Island</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
            image-rendering: crisp-edges;
        }
    </style>
</head>

<body style="overflow: hidden;">
    <canvas id="c" />
    <!-- <script type="module" src="./three.module.js"></script> -->
    <script type="module" src="./ImprovedNoise.js"></script>
    <script type="module">
        import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/build/three.module.js';
        import { OrbitControls } from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/controls/OrbitControls.js';
        import { ImprovedNoise } from './ImprovedNoise.js';

        import { OBJLoader } from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/loaders/OBJLoader.js';
        import { MTLLoader } from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/loaders/MTLLoader.js';
        import { Water } from 'https://threejsfundamentals.org/threejs/resources/threejs/r132/examples/jsm/objects/Water.js';

        var worldWidth = 64, worldDepth = 64;
        var data = generateHeight(worldWidth, worldDepth);

        var canvas = document.getElementById("c");
        var renderer = new THREE.WebGLRenderer({ canvas: canvas });

        // var renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        // renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.setSize(window.innerWidth / 5, window.innerHeight / 5, false);

        renderer.setClearColor()

        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 50000);
        camera.position.set(0, 2000, 4000);
        camera.rotateX(-Math.PI * 0.15);

        var clock = new THREE.Clock();


        var scene = new THREE.Scene();

        var ambientLight = new THREE.AmbientLight(0xaaaaaa, 0.2);
        scene.add(ambientLight);

        var light = new THREE.DirectionalLight(0xffffaa, 1);
        light.color.setHSL(1, 1, 1);
        light.rotateX(- Math.PI / 4);
        light.position.set(2000, 4000, 0);
        // light.position.multiplyScalar(1);
        scene.add(light);

        scene.background = new THREE.Color(0xffffff)

        //skybox
        // const loader = new THREE.TextureLoader();
        // const texture = loader.load(
        //     'images/sky.png',
        //     () => {
        //         const rt = new THREE.WebGLCubeRenderTarget(texture.image.height);
        //         rt.fromEquirectangularTexture(renderer, texture);
        //         scene.background = rt.texture;
        //     });

        // fog
        const color = 0xFFFFFF;  // white
        const near = 500;
        const far = 20000;
        scene.fog = new THREE.Fog(color, near, far);


        // water
        // var material = new THREE.MeshBasicMaterial();
        // material.color.setHex(0x007780);
        // var geometry = new THREE.PlaneBufferGeometry(1000000, 1000000);
        // var mesh = new THREE.Mesh(geometry, material);
        // geometry.rotateX(- Math.PI / 2);
        // geometry.translate(0, -3200, 0)
        // scene.add(mesh);

        const waterGeometry = new THREE.PlaneGeometry(1000000, 1000000);

        let water = new Water(
            waterGeometry,
            {
                textureWidth: 512,
                textureHeight: 512,
                waterNormals: new THREE.TextureLoader().load('images/waternormals.jpg', function (texture) {
                    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
                }),
                sunDirection: new THREE.Vector3(),
                sunColor: 0xffffff,
                waterColor: 0x001e0f,
                distortionScale: 3.7,
                fog: scene.fog !== undefined
            }
        );

        water.position.set(0, -3150, 0)
        water.rotation.x = - Math.PI / 2;
        scene.add(water);
        

        const mtlLoader = new MTLLoader();
        const params = new URLSearchParams(window.location.search);
        const name = params.get("island");

        // local
        // mtlLoader.load(`/test/0047.mtl`, (mtl) => {
        //     mtl.preload();
        //     const objLoader = new OBJLoader();
        //     objLoader.setMaterials(mtl);
        //     // objLoader.load("/test/0047.obj", obj => scene.add(obj));
        //     objLoader.load(`/test/0047.obj`, (root) => {
        //         console.log(root)
        //         root.children[0].scale.set(1000, 1000, 1000)
        //         root.children[0].rotateX(Math.PI / 2);
        //         scene.add(root);
        //     });
        // });

        // prod
        mtlLoader.load(`/api/data/1/${name}.mtl`, (mtl) => {
            mtl.preload();
            const objLoader = new OBJLoader();
            objLoader.setMaterials(mtl);
            // objLoader.load("/test/0047.obj", obj => scene.add(obj));
            objLoader.load(`/api/data/1/${name}.obj`, (root) => {
                console.log(root)
                root.children[0].scale.set(1000, 1000, 1000)
                root.children[0].rotateX(Math.PI / 2);
                scene.add(root);
            });
        });


        function draw() {
            var vertices = geometry.attributes.position.array;
            var colors = [];

            for (var i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {
                vertices[j + 1] = data[i] * 10;
                var c = new THREE.Color();
                var height = vertices[j + 1] / 1000;
                var hue = 0;
                var sat = 1;
                var light = 0.5;
                //water
                if (height < 0.01) {
                    hue = 200 / 360;

                    //sand
                } else if (height < 0.03) {
                    hue = 53 / 360;
                    light = 0.5 * (1 - height * 10);

                    //forest
                } else if (height < 0.3) {
                    hue = 116 / 360;
                    light = 0.1 + (height * 0.8);

                    //cliffs
                }
                else if (height < 0.4) {
                    hue = 116 / 360;
                    sat = 0.5 - (height * 2 - 0.4);
                    light = 0.6 * (height * 2);

                    //snow
                } else {
                    sat = 0;
                    light = 1 * (height * 2);
                }
                c.setHSL(hue, sat, light)
                colors.push(c.r, c.g, c.b);
            }

            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.computeVertexNormals();

        }
        // draw();
        // controls
        // var controls = new OrbitControls( camera, renderer.domElement );
        // // controls.minPolarAngle = Math.PI/0.5;
        // controls.maxPolarAngle = Math.PI * 0.5;
        // controls.minDistance = 3000;
        // controls.maxDistance = 5000;

        const controls = new OrbitControls(camera, canvas);
        controls.target.set(0, -2500, 0);
        // controls.maxPolarAngle = Math.PI / 2;
        controls.update();




        function animate() {
            requestAnimationFrame(animate);
            water.material.uniforms.time.value += 2.0 / 60.0;
            // geometry.rotateY(- Math.PI / 2 * clock.getDelta() / 10);
            renderer.render(scene, camera);
        }

        animate();

        function generateHeight(width, height) {
            var size = width * height, data = new Uint8Array(size),
                perlin = new ImprovedNoise(), quality = 0.2, z = Math.random() * 1000;
            for (var j = 0; j < 4; j++) {
                for (var i = 0; i < size; i++) {
                    var x = i % width, y = ~ ~(i / width);
                    data[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * quality * 1.75);
                    // data[i] = 100;
                    if (j == 3) {
                        // console.log(Math.sqrt(Math.pow(Math.abs(x -32),2) + Math.pow(Math.abs(y -32),2)));
                        var distance = Math.sqrt(Math.pow(Math.abs(x - width * .5), 2) + Math.pow(Math.abs(y - width * .5), 2)) / width;
                        var power = 10;
                        // height = ((Math.cos(Math.PI * distance +1))/2)*power; 
                        // console.log(distance);
                        var height = 1 / (distance * 5 + 1);
                        var height = height * Math.pow(0.5 + 0.5 * Math.cos(Math.PI * distance), power);
                        // console.log(height);
                        data[i] = (data[i] * height) * 2;
                    }
                }
                quality *= 5;

            }
            return data;
        }

    </script>
</body>

</html>